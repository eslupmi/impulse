<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flask Table</title>
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.10.0/dist/cdn.min.js"></script>
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tabulator-tables@5.5.2/dist/js/tabulator.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/tabulator-tables@5.5.2/dist/css/tabulator.min.css" rel="stylesheet">
</head>
<body>
<div id="table-wrapper">
    <input id="filter-input" type="text" placeholder='Enter filters (e.g., status="firing")'>
    <div id="data-table"></div>
</div>

<script>
    const socket = io.connect(location.origin);

    const formatterMap = {
        "datetime": function (cell) {
            const timestamp = cell.getValue();
            return formatTimestamp(timestamp);
        },
        "link": "link"
    };

    function formatTimestamp(unixTimestamp) {
        const date = new Date(unixTimestamp * 1000); // Multiply by 1000 to convert seconds to milliseconds
        const userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
        return date.toLocaleString("en-US", {timeZone: userTimezone});
    }

    const formatterParamsMap = {
        "link": {
            label: function (cell) {
                debugger
                return cell.getValue();
            },
            urlPrefix: "https://",
            target: "_blank",
            url: function (cell) {
                debugger
                return cell.url;
            },
        },
    };

    const sorterMap = {
        "datetime": function (a, b, aRow, bRow, column, dir, sorterParams) {
            return a - b;
        },
        "link": undefined,
    };

    // Initialize Tabulator table
    const table = new Tabulator("#data-table", {
        layout: "fitData",
        index: "uuid",
    });

    fetch('/table_config')
        .then(response => response.json())
        .then(config => {
            const columns = config.map(column => ({
                title: column.title,
                field: column.field,
                sorter: sorterMap[column.type] || "string",
                formatter: formatterMap[column.type] || undefined,
            }));

            setSortingFromBackend(columns);
        });

    const setSortingFromBackend = (columns) => {
        fetch('/table_sorting')
        .then(response => response.json())
        .then(sorters => {
            const tableSorting = [];

            sorters.forEach(sorter => {
                const rule = {
                    column: sorter.column,
                    dir: sorter.direction || "asc",
                };

                if (sorter.order) {
                    rule.sorter = function (a, b, aRow, bRow, column, dir, sorterParams) {
                        const order = sorterParams;
                        const indexA = order.indexOf(a) !== -1 ? order.indexOf(a) : order.length;
                        const indexB = order.indexOf(b) !== -1 ? order.indexOf(b) : order.length;
                        console.log(`Comparing: ${a} (index: ${indexA}) vs ${b} (index: ${indexB})`);
                        return indexA - indexB;
                    };

                    rule.sorterParams = sorter.order;
                }

                tableSorting.push(rule);
            });

            columns.forEach((column, index) => {
                const columnSorter = tableSorting.find(sorter => sorter.column === column.field);
                if (columnSorter) {
                    column.sorter = columnSorter.sorter;
                    column.sorterParams = columnSorter.sorterParams || undefined;
                }
            });

            console.log("Applying Sorting: ", tableSorting);

            // Apply the sorting to the Tabulator table
            table.setColumns(columns);
            table.setSort(tableSorting.reverse());
        })
        .catch(error => console.error("Sorting config fetch error:", error));
    }

    const urlParams = new URLSearchParams(window.location.search);
    const filters = urlParams.get('filters');
    if (filters) {
        table.setFilter(filters.split(',').map(f => {
            const [field, operator, value] = f.split('=');
            return {field, type: operator, value};
        }));
    }

    table.on("cellClick", (e, cell) => {
        const field = cell.getColumn().getField();
        const value = cell.getValue();
        const newFilter = `${field}="${value}"`;
        const existingFilters = urlParams.get('filters') || '';
        const updatedFilters = existingFilters ? `${existingFilters},${newFilter}` : newFilter;
        urlParams.set('filters', updatedFilters);
        window.history.replaceState({}, '', `?${urlParams.toString()}`);
        table.setFilter(field, "=", value);
    });

    document.getElementById("filter-input").addEventListener("change", function () {
        const query = this.value;
        const [field, operator, value] = query.split(/(=|>|<|!=|like)/);
        table.setFilter(field.trim(), operator.trim(), value.trim());
        const filters = urlParams.get('filters') || '';
        urlParams.set('filters', filters ? `${filters},${query}` : query);
        window.history.replaceState({}, '', `?${urlParams.toString()}`);
    });

    // Handle WebSocket Events
    socket.on("add_row", (rowData) => {
        table.addRow(rowData);
        table.setSort(table.getSorters());
    });

    socket.on("update_row", (rowData) => {
        table.updateOrAddData([rowData]);
        table.setSort(table.getSorters());
    });

    socket.on("remove_row", (rowData) => {
        const rows = table.searchRows('uuid', '=', rowData.uuid);
        rows.forEach(row => row.delete());
    });

    socket.on("update_data", (data) => {
        // Set the entire table data
        table.setData(data);
        table.setSort(table.getSorters());
    });

    // Request the initial table data
    socket.emit("request_data");
</script>
</body>
</html>
