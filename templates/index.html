<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flask Table</title>
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.10.0/dist/cdn.min.js"></script>
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tabulator-tables@5.5.2/dist/js/tabulator.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/tabulator-tables@5.5.2/dist/css/tabulator.min.css" rel="stylesheet">
</head>
<body>
<div id="table-wrapper">
    <input id="filter-input" type="text" placeholder='Enter filters (e.g., status="firing")'>
    <div id="data-table"></div>
</div>

<script>
    const socket = io.connect(location.origin);

    // Formatters for different column types
    const formatterMap = {
        "datetime": cell => formatTimestamp(cell.getValue()),
        "link": "link",
    };

    function formatTimestamp(unixTimestamp) {
        const date = new Date(unixTimestamp * 1000);
        return date.toLocaleString("en-US", {
            timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
        });
    }

    // Formatter parameters (for links, etc.)
    const formatterParamsMap = {
        "link": (data) => {
            return {
                label: data.label,
                urlPrefix: "https://",
                target: "_blank",
                url: data.url,
            };
        },
    };

    // Custom sorters
    const sorterMap = {
        "datetime": (a, b) => a - b,
        "link": undefined,
    };

    // Initialize Tabulator instance
    const table = new Tabulator("#data-table", {
        layout: "fitData",
        index: "uuid",
    });

    // Fetch table configuration and sorting, then initialize the table
    async function initializeTable() {
        try {
            const [configResponse, sortingResponse] = await Promise.all([
                fetch('/table_config').then(res => res.json()),
                fetch('/table_sorting').then(res => res.json())
            ]);

            const columns = configResponse.map(column => ({
                title: column.title,
                field: column.field,
                sorter: column.type in sorterMap ? sorterMap[column.type] : undefined,
                formatter: formatterMap[column.type] || undefined,
                formatterParams: column.type in formatterParamsMap ? formatterParamsMap[column.type](column) : undefined,
            }));

            applySorting(columns, sortingResponse);
        } catch (error) {
            console.error("Error initializing table:", error);
        }
    }

    // Apply sorting to the Tabulator instance
    function applySorting(columns, sorters) {
        const tableSorting = sorters.map(sorter => {
            const rule = {
                column: sorter.column,
                dir: sorter.direction || "asc",
            };

            if (sorter.order) {
                rule.sorter = function (a, b, aRow, bRow, column, dir, sorterParams) {
                    const order = sorterParams;
                    const indexA = order.indexOf(a) !== -1 ? order.indexOf(a) : order.length;
                    const indexB = order.indexOf(b) !== -1 ? order.indexOf(b) : order.length;
                    return indexA - indexB;
                };
                rule.sorterParams = sorter.order;
            }

            return rule;
        });

        columns.forEach(column => {
            const columnSorter = tableSorting.find(sorter => sorter.column === column.field);
            if (columnSorter) {
                column.sorter = columnSorter.sorter;
                column.sorterParams = columnSorter.sorterParams || undefined;
            }
        });

        console.log("Applying Sorting:", tableSorting);

        table.setColumns(columns);
        table.setSort(tableSorting.reverse());
    }

    // Handle URL filters
    function applyUrlFilters() {
        const urlParams = new URLSearchParams(window.location.search);
        const filters = urlParams.get('filters');

        if (filters) {
            const parsedFilters = filters.split(',').map(f => {
                const [field, operator, value] = f.split('=');
                return {field, type: operator, value};
            });

            table.setFilter(parsedFilters);
        }
    }

    // Add filtering from table clicks
    function setupTableFiltering() {
        table.on("cellClick", (e, cell) => {
            const field = cell.getColumn().getField();
            const value = cell.getValue();
            const newFilter = `${field}="${value}"`;

            const urlParams = new URLSearchParams(window.location.search);
            const existingFilters = urlParams.get('filters') || '';
            const updatedFilters = existingFilters ? `${existingFilters},${newFilter}` : newFilter;

            urlParams.set('filters', updatedFilters);
            window.history.replaceState({}, '', `?${urlParams.toString()}`);

            table.setFilter(field, "=", value);
        });

        document.getElementById("filter-input").addEventListener("change", function () {
            const query = this.value;
            const [field, operator, value] = query.split(/(=|>|<|!=|like)/);
            table.setFilter(field.trim(), operator.trim(), value.trim());

            const urlParams = new URLSearchParams(window.location.search);
            const existingFilters = urlParams.get('filters') || '';
            urlParams.set('filters', existingFilters ? `${existingFilters},${query}` : query);
            window.history.replaceState({}, '', `?${urlParams.toString()}`);
        });
    }

    // Handle WebSocket Events
    function setupWebSocketEvents() {
        socket.on("add_row", rowData => {
            table.addRow(rowData);
            table.setSort(table.getSorters());
        });

        socket.on("update_row", rowData => {
            table.updateOrAddData([rowData]);
            table.setSort(table.getSorters());
        });

        socket.on("remove_row", rowData => {
            const rows = table.searchRows('uuid', '=', rowData.uuid);
            rows.forEach(row => row.delete());
        });

        socket.on("update_data", data => {
            table.setData(data);
            table.setSort(table.getSorters());
        });

        // Request initial data from WebSocket
        socket.emit("request_data");
    }

    // **Initialize Everything**
    initializeTable();
    applyUrlFilters();
    setupTableFiltering();
    setupWebSocketEvents();

</script>
</body>
</html>
